// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Struct.proto

#ifndef PROTOBUF_Struct_2eproto__INCLUDED
#define PROTOBUF_Struct_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace lhchat {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Struct_2eproto();
void protobuf_AssignDesc_Struct_2eproto();
void protobuf_ShutdownFile_Struct_2eproto();

class InfoVersion;
class UserPublicInfo;
class FriendExtrasInfo;
class MessageItem;

enum UserInfoIndex {
  UII_GAMEID = 0,
  UII_GENDER = 1,
  UII_NICKNAME = 2,
  UII_RANKSCORE = 3,
  UII_EXPERIENCE = 4,
  UII_MEMBERPOINT = 5,
  UII_UNDERWRITE = 6,
  UII_MASTERORDER = 7,
  UII_FACEID = 8,
  UII_LOVELINESS = 9
};
bool UserInfoIndex_IsValid(int value);
const UserInfoIndex UserInfoIndex_MIN = UII_GAMEID;
const UserInfoIndex UserInfoIndex_MAX = UII_LOVELINESS;
const int UserInfoIndex_ARRAYSIZE = UserInfoIndex_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserInfoIndex_descriptor();
inline const ::std::string& UserInfoIndex_Name(UserInfoIndex value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserInfoIndex_descriptor(), value);
}
inline bool UserInfoIndex_Parse(
    const ::std::string& name, UserInfoIndex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserInfoIndex>(
    UserInfoIndex_descriptor(), name, value);
}
enum ApplyMode {
  AM_NONE = 0,
  AM_SEARCH = 1,
  AM_SCAN_QRCODE = 2,
  AM_VISIT_CARD = 3
};
bool ApplyMode_IsValid(int value);
const ApplyMode ApplyMode_MIN = AM_NONE;
const ApplyMode ApplyMode_MAX = AM_VISIT_CARD;
const int ApplyMode_ARRAYSIZE = ApplyMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ApplyMode_descriptor();
inline const ::std::string& ApplyMode_Name(ApplyMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ApplyMode_descriptor(), value);
}
inline bool ApplyMode_Parse(
    const ::std::string& name, ApplyMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ApplyMode>(
    ApplyMode_descriptor(), name, value);
}
enum ApplyType {
  AT_NONE = 0,
  AT_PERSON = 1,
  AT_GROUP = 2
};
bool ApplyType_IsValid(int value);
const ApplyType ApplyType_MIN = AT_NONE;
const ApplyType ApplyType_MAX = AT_GROUP;
const int ApplyType_ARRAYSIZE = ApplyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ApplyType_descriptor();
inline const ::std::string& ApplyType_Name(ApplyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ApplyType_descriptor(), value);
}
inline bool ApplyType_Parse(
    const ::std::string& name, ApplyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ApplyType>(
    ApplyType_descriptor(), name, value);
}
enum SearchType {
  ST_BY_UID = 1,
  ST_BY_GID = 2
};
bool SearchType_IsValid(int value);
const SearchType SearchType_MIN = ST_BY_UID;
const SearchType SearchType_MAX = ST_BY_GID;
const int SearchType_ARRAYSIZE = SearchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchType_descriptor();
inline const ::std::string& SearchType_Name(SearchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchType_descriptor(), value);
}
inline bool SearchType_Parse(
    const ::std::string& name, SearchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchType>(
    SearchType_descriptor(), name, value);
}
enum Applystate {
  AT_WAIT = 0,
  AT_AGREE = 1,
  AT_REFUSE = 2,
  AT_EXPIRED = 3
};
bool Applystate_IsValid(int value);
const Applystate Applystate_MIN = AT_WAIT;
const Applystate Applystate_MAX = AT_EXPIRED;
const int Applystate_ARRAYSIZE = Applystate_MAX + 1;

const ::google::protobuf::EnumDescriptor* Applystate_descriptor();
inline const ::std::string& Applystate_Name(Applystate value) {
  return ::google::protobuf::internal::NameOfEnum(
    Applystate_descriptor(), value);
}
inline bool Applystate_Parse(
    const ::std::string& name, Applystate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Applystate>(
    Applystate_descriptor(), name, value);
}
enum ApplyResult {
  AR_NONE = 0,
  AR_AGREE = 1,
  AR_REFUSE = 2
};
bool ApplyResult_IsValid(int value);
const ApplyResult ApplyResult_MIN = AR_NONE;
const ApplyResult ApplyResult_MAX = AR_REFUSE;
const int ApplyResult_ARRAYSIZE = ApplyResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* ApplyResult_descriptor();
inline const ::std::string& ApplyResult_Name(ApplyResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    ApplyResult_descriptor(), value);
}
inline bool ApplyResult_Parse(
    const ::std::string& name, ApplyResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ApplyResult>(
    ApplyResult_descriptor(), name, value);
}
enum UserRelation {
  UR_NONE = 0,
  UR_STRANGER = 1,
  UR_FRIEND = 2,
  UR_BLACKLIST = 3
};
bool UserRelation_IsValid(int value);
const UserRelation UserRelation_MIN = UR_NONE;
const UserRelation UserRelation_MAX = UR_BLACKLIST;
const int UserRelation_ARRAYSIZE = UserRelation_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserRelation_descriptor();
inline const ::std::string& UserRelation_Name(UserRelation value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserRelation_descriptor(), value);
}
inline bool UserRelation_Parse(
    const ::std::string& name, UserRelation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserRelation>(
    UserRelation_descriptor(), name, value);
}
enum MessageKind {
  MK_NONE = 0,
  MK_WORLD = 1,
  MK_GROUP = 2,
  MK_PRIVATE = 3
};
bool MessageKind_IsValid(int value);
const MessageKind MessageKind_MIN = MK_NONE;
const MessageKind MessageKind_MAX = MK_PRIVATE;
const int MessageKind_ARRAYSIZE = MessageKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageKind_descriptor();
inline const ::std::string& MessageKind_Name(MessageKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageKind_descriptor(), value);
}
inline bool MessageKind_Parse(
    const ::std::string& name, MessageKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageKind>(
    MessageKind_descriptor(), name, value);
}
enum MsgQueueKind {
  MQK_NONE = 0,
  MQK_WORLD = 1,
  MQK_PERSON = 2
};
bool MsgQueueKind_IsValid(int value);
const MsgQueueKind MsgQueueKind_MIN = MQK_NONE;
const MsgQueueKind MsgQueueKind_MAX = MQK_PERSON;
const int MsgQueueKind_ARRAYSIZE = MsgQueueKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgQueueKind_descriptor();
inline const ::std::string& MsgQueueKind_Name(MsgQueueKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgQueueKind_descriptor(), value);
}
inline bool MsgQueueKind_Parse(
    const ::std::string& name, MsgQueueKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgQueueKind>(
    MsgQueueKind_descriptor(), name, value);
}
enum ChannelKind {
  CK_NONE = 0,
  CK_SYSTEM = 1,
  CK_TABLE = 2
};
bool ChannelKind_IsValid(int value);
const ChannelKind ChannelKind_MIN = CK_NONE;
const ChannelKind ChannelKind_MAX = CK_TABLE;
const int ChannelKind_ARRAYSIZE = ChannelKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChannelKind_descriptor();
inline const ::std::string& ChannelKind_Name(ChannelKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChannelKind_descriptor(), value);
}
inline bool ChannelKind_Parse(
    const ::std::string& name, ChannelKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelKind>(
    ChannelKind_descriptor(), name, value);
}
enum OperateResultCode {
  ORC_NONE = 0,
  ORC_SUCCESS = 1,
  ORC_FAILURE = 2,
  ORC_INFO_NOTEXIST = 3,
  ORC_DB_EXCEPTION = 4,
  ORC_TRY_AGAIN_LATER = 99
};
bool OperateResultCode_IsValid(int value);
const OperateResultCode OperateResultCode_MIN = ORC_NONE;
const OperateResultCode OperateResultCode_MAX = ORC_TRY_AGAIN_LATER;
const int OperateResultCode_ARRAYSIZE = OperateResultCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperateResultCode_descriptor();
inline const ::std::string& OperateResultCode_Name(OperateResultCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperateResultCode_descriptor(), value);
}
inline bool OperateResultCode_Parse(
    const ::std::string& name, OperateResultCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperateResultCode>(
    OperateResultCode_descriptor(), name, value);
}
// ===================================================================

class InfoVersion : public ::google::protobuf::Message {
 public:
  InfoVersion();
  virtual ~InfoVersion();
  
  InfoVersion(const InfoVersion& from);
  
  inline InfoVersion& operator=(const InfoVersion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoVersion& default_instance();
  
  void Swap(InfoVersion* other);
  
  // implements Message ----------------------------------------------
  
  InfoVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfoVersion& from);
  void MergeFrom(const InfoVersion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 infoVersion = 1;
  inline int infoversion_size() const;
  inline void clear_infoversion();
  static const int kInfoVersionFieldNumber = 1;
  inline ::google::protobuf::int32 infoversion(int index) const;
  inline void set_infoversion(int index, ::google::protobuf::int32 value);
  inline void add_infoversion(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      infoversion() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_infoversion();
  
  // @@protoc_insertion_point(class_scope:lhchat.InfoVersion)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > infoversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Struct_2eproto();
  friend void protobuf_AssignDesc_Struct_2eproto();
  friend void protobuf_ShutdownFile_Struct_2eproto();
  
  void InitAsDefaultInstance();
  static InfoVersion* default_instance_;
};
// -------------------------------------------------------------------

class UserPublicInfo : public ::google::protobuf::Message {
 public:
  UserPublicInfo();
  virtual ~UserPublicInfo();
  
  UserPublicInfo(const UserPublicInfo& from);
  
  inline UserPublicInfo& operator=(const UserPublicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPublicInfo& default_instance();
  
  void Swap(UserPublicInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserPublicInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserPublicInfo& from);
  void MergeFrom(const UserPublicInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // optional int32 gameId = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);
  
  // optional int32 gender = 3;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 3;
  inline ::google::protobuf::int32 gender() const;
  inline void set_gender(::google::protobuf::int32 value);
  
  // optional int32 faceId = 4;
  inline bool has_faceid() const;
  inline void clear_faceid();
  static const int kFaceIdFieldNumber = 4;
  inline ::google::protobuf::int32 faceid() const;
  inline void set_faceid(::google::protobuf::int32 value);
  
  // optional int32 customId = 5;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIdFieldNumber = 5;
  inline ::google::protobuf::int32 customid() const;
  inline void set_customid(::google::protobuf::int32 value);
  
  // optional bytes nickname = 6;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 6;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const void* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // optional bytes underwrite = 7;
  inline bool has_underwrite() const;
  inline void clear_underwrite();
  static const int kUnderwriteFieldNumber = 7;
  inline const ::std::string& underwrite() const;
  inline void set_underwrite(const ::std::string& value);
  inline void set_underwrite(const char* value);
  inline void set_underwrite(const void* value, size_t size);
  inline ::std::string* mutable_underwrite();
  inline ::std::string* release_underwrite();
  
  // optional int32 experience = 8;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 8;
  inline ::google::protobuf::int32 experience() const;
  inline void set_experience(::google::protobuf::int32 value);
  
  // optional int32 memberPoint = 9;
  inline bool has_memberpoint() const;
  inline void clear_memberpoint();
  static const int kMemberPointFieldNumber = 9;
  inline ::google::protobuf::int32 memberpoint() const;
  inline void set_memberpoint(::google::protobuf::int32 value);
  
  // optional int64 rankScore = 10;
  inline bool has_rankscore() const;
  inline void clear_rankscore();
  static const int kRankScoreFieldNumber = 10;
  inline ::google::protobuf::int64 rankscore() const;
  inline void set_rankscore(::google::protobuf::int64 value);
  
  // optional int32 masterOrder = 11;
  inline bool has_masterorder() const;
  inline void clear_masterorder();
  static const int kMasterOrderFieldNumber = 11;
  inline ::google::protobuf::int32 masterorder() const;
  inline void set_masterorder(::google::protobuf::int32 value);
  
  // optional int32 loveliness = 12;
  inline bool has_loveliness() const;
  inline void clear_loveliness();
  static const int kLovelinessFieldNumber = 12;
  inline ::google::protobuf::int32 loveliness() const;
  inline void set_loveliness(::google::protobuf::int32 value);
  
  // required int32 infoPublic = 98;
  inline bool has_infopublic() const;
  inline void clear_infopublic();
  static const int kInfoPublicFieldNumber = 98;
  inline ::google::protobuf::int32 infopublic() const;
  inline void set_infopublic(::google::protobuf::int32 value);
  
  // required bytes infoVersion = 99;
  inline bool has_infoversion() const;
  inline void clear_infoversion();
  static const int kInfoVersionFieldNumber = 99;
  inline const ::std::string& infoversion() const;
  inline void set_infoversion(const ::std::string& value);
  inline void set_infoversion(const char* value);
  inline void set_infoversion(const void* value, size_t size);
  inline ::std::string* mutable_infoversion();
  inline ::std::string* release_infoversion();
  
  // @@protoc_insertion_point(class_scope:lhchat.UserPublicInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_faceid();
  inline void clear_has_faceid();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_underwrite();
  inline void clear_has_underwrite();
  inline void set_has_experience();
  inline void clear_has_experience();
  inline void set_has_memberpoint();
  inline void clear_has_memberpoint();
  inline void set_has_rankscore();
  inline void clear_has_rankscore();
  inline void set_has_masterorder();
  inline void clear_has_masterorder();
  inline void set_has_loveliness();
  inline void clear_has_loveliness();
  inline void set_has_infopublic();
  inline void clear_has_infopublic();
  inline void set_has_infoversion();
  inline void clear_has_infoversion();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 gender_;
  ::google::protobuf::int32 faceid_;
  ::std::string* nickname_;
  ::google::protobuf::int32 customid_;
  ::google::protobuf::int32 experience_;
  ::std::string* underwrite_;
  ::google::protobuf::int64 rankscore_;
  ::google::protobuf::int32 memberpoint_;
  ::google::protobuf::int32 masterorder_;
  ::google::protobuf::int32 loveliness_;
  ::google::protobuf::int32 infopublic_;
  ::std::string* infoversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_Struct_2eproto();
  friend void protobuf_AssignDesc_Struct_2eproto();
  friend void protobuf_ShutdownFile_Struct_2eproto();
  
  void InitAsDefaultInstance();
  static UserPublicInfo* default_instance_;
};
// -------------------------------------------------------------------

class FriendExtrasInfo : public ::google::protobuf::Message {
 public:
  FriendExtrasInfo();
  virtual ~FriendExtrasInfo();
  
  FriendExtrasInfo(const FriendExtrasInfo& from);
  
  inline FriendExtrasInfo& operator=(const FriendExtrasInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendExtrasInfo& default_instance();
  
  void Swap(FriendExtrasInfo* other);
  
  // implements Message ----------------------------------------------
  
  FriendExtrasInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendExtrasInfo& from);
  void MergeFrom(const FriendExtrasInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 friendid = 1;
  inline bool has_friendid() const;
  inline void clear_friendid();
  static const int kFriendidFieldNumber = 1;
  inline ::google::protobuf::int32 friendid() const;
  inline void set_friendid(::google::protobuf::int32 value);
  
  // optional bytes remarks = 2;
  inline bool has_remarks() const;
  inline void clear_remarks();
  static const int kRemarksFieldNumber = 2;
  inline const ::std::string& remarks() const;
  inline void set_remarks(const ::std::string& value);
  inline void set_remarks(const char* value);
  inline void set_remarks(const void* value, size_t size);
  inline ::std::string* mutable_remarks();
  inline ::std::string* release_remarks();
  
  // optional .lhchat.ApplyMode applyMode = 3;
  inline bool has_applymode() const;
  inline void clear_applymode();
  static const int kApplyModeFieldNumber = 3;
  inline lhchat::ApplyMode applymode() const;
  inline void set_applymode(lhchat::ApplyMode value);
  
  // @@protoc_insertion_point(class_scope:lhchat.FriendExtrasInfo)
 private:
  inline void set_has_friendid();
  inline void clear_has_friendid();
  inline void set_has_remarks();
  inline void clear_has_remarks();
  inline void set_has_applymode();
  inline void clear_has_applymode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* remarks_;
  ::google::protobuf::int32 friendid_;
  int applymode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Struct_2eproto();
  friend void protobuf_AssignDesc_Struct_2eproto();
  friend void protobuf_ShutdownFile_Struct_2eproto();
  
  void InitAsDefaultInstance();
  static FriendExtrasInfo* default_instance_;
};
// -------------------------------------------------------------------

class MessageItem : public ::google::protobuf::Message {
 public:
  MessageItem();
  virtual ~MessageItem();
  
  MessageItem(const MessageItem& from);
  
  inline MessageItem& operator=(const MessageItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageItem& default_instance();
  
  void Swap(MessageItem* other);
  
  // implements Message ----------------------------------------------
  
  MessageItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageItem& from);
  void MergeFrom(const MessageItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 msgId = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::uint64 msgid() const;
  inline void set_msgid(::google::protobuf::uint64 value);
  
  // required int32 fromId = 2;
  inline bool has_fromid() const;
  inline void clear_fromid();
  static const int kFromIdFieldNumber = 2;
  inline ::google::protobuf::int32 fromid() const;
  inline void set_fromid(::google::protobuf::int32 value);
  
  // optional int32 fromgid = 9;
  inline bool has_fromgid() const;
  inline void clear_fromgid();
  static const int kFromgidFieldNumber = 9;
  inline ::google::protobuf::int32 fromgid() const;
  inline void set_fromgid(::google::protobuf::int32 value);
  
  // optional bytes infoVersion = 10;
  inline bool has_infoversion() const;
  inline void clear_infoversion();
  static const int kInfoVersionFieldNumber = 10;
  inline const ::std::string& infoversion() const;
  inline void set_infoversion(const ::std::string& value);
  inline void set_infoversion(const char* value);
  inline void set_infoversion(const void* value, size_t size);
  inline ::std::string* mutable_infoversion();
  inline ::std::string* release_infoversion();
  
  // required int32 toId = 3;
  inline bool has_toid() const;
  inline void clear_toid();
  static const int kToIdFieldNumber = 3;
  inline ::google::protobuf::int32 toid() const;
  inline void set_toid(::google::protobuf::int32 value);
  
  // optional .lhchat.MessageKind msgKind = 4;
  inline bool has_msgkind() const;
  inline void clear_msgkind();
  static const int kMsgKindFieldNumber = 4;
  inline lhchat::MessageKind msgkind() const;
  inline void set_msgkind(lhchat::MessageKind value);
  
  // required int32 showType = 5;
  inline bool has_showtype() const;
  inline void clear_showtype();
  static const int kShowTypeFieldNumber = 5;
  inline ::google::protobuf::int32 showtype() const;
  inline void set_showtype(::google::protobuf::int32 value);
  
  // required int32 contentType = 6;
  inline bool has_contenttype() const;
  inline void clear_contenttype();
  static const int kContentTypeFieldNumber = 6;
  inline ::google::protobuf::int32 contenttype() const;
  inline void set_contenttype(::google::protobuf::int32 value);
  
  // required bytes contentData = 7;
  inline bool has_contentdata() const;
  inline void clear_contentdata();
  static const int kContentDataFieldNumber = 7;
  inline const ::std::string& contentdata() const;
  inline void set_contentdata(const ::std::string& value);
  inline void set_contentdata(const char* value);
  inline void set_contentdata(const void* value, size_t size);
  inline ::std::string* mutable_contentdata();
  inline ::std::string* release_contentdata();
  
  // required uint64 generatedTime = 8;
  inline bool has_generatedtime() const;
  inline void clear_generatedtime();
  static const int kGeneratedTimeFieldNumber = 8;
  inline ::google::protobuf::uint64 generatedtime() const;
  inline void set_generatedtime(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:lhchat.MessageItem)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_fromid();
  inline void clear_has_fromid();
  inline void set_has_fromgid();
  inline void clear_has_fromgid();
  inline void set_has_infoversion();
  inline void clear_has_infoversion();
  inline void set_has_toid();
  inline void clear_has_toid();
  inline void set_has_msgkind();
  inline void clear_has_msgkind();
  inline void set_has_showtype();
  inline void clear_has_showtype();
  inline void set_has_contenttype();
  inline void clear_has_contenttype();
  inline void set_has_contentdata();
  inline void clear_has_contentdata();
  inline void set_has_generatedtime();
  inline void clear_has_generatedtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 msgid_;
  ::google::protobuf::int32 fromid_;
  ::google::protobuf::int32 fromgid_;
  ::std::string* infoversion_;
  ::google::protobuf::int32 toid_;
  int msgkind_;
  ::google::protobuf::int32 showtype_;
  ::google::protobuf::int32 contenttype_;
  ::std::string* contentdata_;
  ::google::protobuf::uint64 generatedtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_Struct_2eproto();
  friend void protobuf_AssignDesc_Struct_2eproto();
  friend void protobuf_ShutdownFile_Struct_2eproto();
  
  void InitAsDefaultInstance();
  static MessageItem* default_instance_;
};
// ===================================================================


// ===================================================================

// InfoVersion

// repeated int32 infoVersion = 1;
inline int InfoVersion::infoversion_size() const {
  return infoversion_.size();
}
inline void InfoVersion::clear_infoversion() {
  infoversion_.Clear();
}
inline ::google::protobuf::int32 InfoVersion::infoversion(int index) const {
  return infoversion_.Get(index);
}
inline void InfoVersion::set_infoversion(int index, ::google::protobuf::int32 value) {
  infoversion_.Set(index, value);
}
inline void InfoVersion::add_infoversion(::google::protobuf::int32 value) {
  infoversion_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InfoVersion::infoversion() const {
  return infoversion_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InfoVersion::mutable_infoversion() {
  return &infoversion_;
}

// -------------------------------------------------------------------

// UserPublicInfo

// required int32 uid = 1;
inline bool UserPublicInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPublicInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPublicInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPublicInfo::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 UserPublicInfo::uid() const {
  return uid_;
}
inline void UserPublicInfo::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 gameId = 2;
inline bool UserPublicInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPublicInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPublicInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPublicInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 UserPublicInfo::gameid() const {
  return gameid_;
}
inline void UserPublicInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 gender = 3;
inline bool UserPublicInfo::has_gender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPublicInfo::set_has_gender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPublicInfo::clear_has_gender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPublicInfo::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::google::protobuf::int32 UserPublicInfo::gender() const {
  return gender_;
}
inline void UserPublicInfo::set_gender(::google::protobuf::int32 value) {
  set_has_gender();
  gender_ = value;
}

// optional int32 faceId = 4;
inline bool UserPublicInfo::has_faceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserPublicInfo::set_has_faceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserPublicInfo::clear_has_faceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserPublicInfo::clear_faceid() {
  faceid_ = 0;
  clear_has_faceid();
}
inline ::google::protobuf::int32 UserPublicInfo::faceid() const {
  return faceid_;
}
inline void UserPublicInfo::set_faceid(::google::protobuf::int32 value) {
  set_has_faceid();
  faceid_ = value;
}

// optional int32 customId = 5;
inline bool UserPublicInfo::has_customid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserPublicInfo::set_has_customid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserPublicInfo::clear_has_customid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserPublicInfo::clear_customid() {
  customid_ = 0;
  clear_has_customid();
}
inline ::google::protobuf::int32 UserPublicInfo::customid() const {
  return customid_;
}
inline void UserPublicInfo::set_customid(::google::protobuf::int32 value) {
  set_has_customid();
  customid_ = value;
}

// optional bytes nickname = 6;
inline bool UserPublicInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserPublicInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserPublicInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserPublicInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserPublicInfo::nickname() const {
  return *nickname_;
}
inline void UserPublicInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void UserPublicInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void UserPublicInfo::set_nickname(const void* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPublicInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* UserPublicInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes underwrite = 7;
inline bool UserPublicInfo::has_underwrite() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserPublicInfo::set_has_underwrite() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserPublicInfo::clear_has_underwrite() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserPublicInfo::clear_underwrite() {
  if (underwrite_ != &::google::protobuf::internal::kEmptyString) {
    underwrite_->clear();
  }
  clear_has_underwrite();
}
inline const ::std::string& UserPublicInfo::underwrite() const {
  return *underwrite_;
}
inline void UserPublicInfo::set_underwrite(const ::std::string& value) {
  set_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    underwrite_ = new ::std::string;
  }
  underwrite_->assign(value);
}
inline void UserPublicInfo::set_underwrite(const char* value) {
  set_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    underwrite_ = new ::std::string;
  }
  underwrite_->assign(value);
}
inline void UserPublicInfo::set_underwrite(const void* value, size_t size) {
  set_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    underwrite_ = new ::std::string;
  }
  underwrite_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPublicInfo::mutable_underwrite() {
  set_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    underwrite_ = new ::std::string;
  }
  return underwrite_;
}
inline ::std::string* UserPublicInfo::release_underwrite() {
  clear_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underwrite_;
    underwrite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 experience = 8;
inline bool UserPublicInfo::has_experience() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserPublicInfo::set_has_experience() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserPublicInfo::clear_has_experience() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserPublicInfo::clear_experience() {
  experience_ = 0;
  clear_has_experience();
}
inline ::google::protobuf::int32 UserPublicInfo::experience() const {
  return experience_;
}
inline void UserPublicInfo::set_experience(::google::protobuf::int32 value) {
  set_has_experience();
  experience_ = value;
}

// optional int32 memberPoint = 9;
inline bool UserPublicInfo::has_memberpoint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserPublicInfo::set_has_memberpoint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserPublicInfo::clear_has_memberpoint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserPublicInfo::clear_memberpoint() {
  memberpoint_ = 0;
  clear_has_memberpoint();
}
inline ::google::protobuf::int32 UserPublicInfo::memberpoint() const {
  return memberpoint_;
}
inline void UserPublicInfo::set_memberpoint(::google::protobuf::int32 value) {
  set_has_memberpoint();
  memberpoint_ = value;
}

// optional int64 rankScore = 10;
inline bool UserPublicInfo::has_rankscore() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserPublicInfo::set_has_rankscore() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserPublicInfo::clear_has_rankscore() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserPublicInfo::clear_rankscore() {
  rankscore_ = GOOGLE_LONGLONG(0);
  clear_has_rankscore();
}
inline ::google::protobuf::int64 UserPublicInfo::rankscore() const {
  return rankscore_;
}
inline void UserPublicInfo::set_rankscore(::google::protobuf::int64 value) {
  set_has_rankscore();
  rankscore_ = value;
}

// optional int32 masterOrder = 11;
inline bool UserPublicInfo::has_masterorder() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserPublicInfo::set_has_masterorder() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserPublicInfo::clear_has_masterorder() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserPublicInfo::clear_masterorder() {
  masterorder_ = 0;
  clear_has_masterorder();
}
inline ::google::protobuf::int32 UserPublicInfo::masterorder() const {
  return masterorder_;
}
inline void UserPublicInfo::set_masterorder(::google::protobuf::int32 value) {
  set_has_masterorder();
  masterorder_ = value;
}

// optional int32 loveliness = 12;
inline bool UserPublicInfo::has_loveliness() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserPublicInfo::set_has_loveliness() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserPublicInfo::clear_has_loveliness() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserPublicInfo::clear_loveliness() {
  loveliness_ = 0;
  clear_has_loveliness();
}
inline ::google::protobuf::int32 UserPublicInfo::loveliness() const {
  return loveliness_;
}
inline void UserPublicInfo::set_loveliness(::google::protobuf::int32 value) {
  set_has_loveliness();
  loveliness_ = value;
}

// required int32 infoPublic = 98;
inline bool UserPublicInfo::has_infopublic() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserPublicInfo::set_has_infopublic() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserPublicInfo::clear_has_infopublic() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserPublicInfo::clear_infopublic() {
  infopublic_ = 0;
  clear_has_infopublic();
}
inline ::google::protobuf::int32 UserPublicInfo::infopublic() const {
  return infopublic_;
}
inline void UserPublicInfo::set_infopublic(::google::protobuf::int32 value) {
  set_has_infopublic();
  infopublic_ = value;
}

// required bytes infoVersion = 99;
inline bool UserPublicInfo::has_infoversion() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserPublicInfo::set_has_infoversion() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserPublicInfo::clear_has_infoversion() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserPublicInfo::clear_infoversion() {
  if (infoversion_ != &::google::protobuf::internal::kEmptyString) {
    infoversion_->clear();
  }
  clear_has_infoversion();
}
inline const ::std::string& UserPublicInfo::infoversion() const {
  return *infoversion_;
}
inline void UserPublicInfo::set_infoversion(const ::std::string& value) {
  set_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    infoversion_ = new ::std::string;
  }
  infoversion_->assign(value);
}
inline void UserPublicInfo::set_infoversion(const char* value) {
  set_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    infoversion_ = new ::std::string;
  }
  infoversion_->assign(value);
}
inline void UserPublicInfo::set_infoversion(const void* value, size_t size) {
  set_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    infoversion_ = new ::std::string;
  }
  infoversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPublicInfo::mutable_infoversion() {
  set_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    infoversion_ = new ::std::string;
  }
  return infoversion_;
}
inline ::std::string* UserPublicInfo::release_infoversion() {
  clear_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = infoversion_;
    infoversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FriendExtrasInfo

// required int32 friendid = 1;
inline bool FriendExtrasInfo::has_friendid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendExtrasInfo::set_has_friendid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendExtrasInfo::clear_has_friendid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendExtrasInfo::clear_friendid() {
  friendid_ = 0;
  clear_has_friendid();
}
inline ::google::protobuf::int32 FriendExtrasInfo::friendid() const {
  return friendid_;
}
inline void FriendExtrasInfo::set_friendid(::google::protobuf::int32 value) {
  set_has_friendid();
  friendid_ = value;
}

// optional bytes remarks = 2;
inline bool FriendExtrasInfo::has_remarks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendExtrasInfo::set_has_remarks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendExtrasInfo::clear_has_remarks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendExtrasInfo::clear_remarks() {
  if (remarks_ != &::google::protobuf::internal::kEmptyString) {
    remarks_->clear();
  }
  clear_has_remarks();
}
inline const ::std::string& FriendExtrasInfo::remarks() const {
  return *remarks_;
}
inline void FriendExtrasInfo::set_remarks(const ::std::string& value) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(value);
}
inline void FriendExtrasInfo::set_remarks(const char* value) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(value);
}
inline void FriendExtrasInfo::set_remarks(const void* value, size_t size) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendExtrasInfo::mutable_remarks() {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  return remarks_;
}
inline ::std::string* FriendExtrasInfo::release_remarks() {
  clear_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remarks_;
    remarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .lhchat.ApplyMode applyMode = 3;
inline bool FriendExtrasInfo::has_applymode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendExtrasInfo::set_has_applymode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendExtrasInfo::clear_has_applymode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendExtrasInfo::clear_applymode() {
  applymode_ = 0;
  clear_has_applymode();
}
inline lhchat::ApplyMode FriendExtrasInfo::applymode() const {
  return static_cast< lhchat::ApplyMode >(applymode_);
}
inline void FriendExtrasInfo::set_applymode(lhchat::ApplyMode value) {
  GOOGLE_DCHECK(lhchat::ApplyMode_IsValid(value));
  set_has_applymode();
  applymode_ = value;
}

// -------------------------------------------------------------------

// MessageItem

// required uint64 msgId = 1;
inline bool MessageItem::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageItem::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageItem::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageItem::clear_msgid() {
  msgid_ = GOOGLE_ULONGLONG(0);
  clear_has_msgid();
}
inline ::google::protobuf::uint64 MessageItem::msgid() const {
  return msgid_;
}
inline void MessageItem::set_msgid(::google::protobuf::uint64 value) {
  set_has_msgid();
  msgid_ = value;
}

// required int32 fromId = 2;
inline bool MessageItem::has_fromid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageItem::set_has_fromid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageItem::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageItem::clear_fromid() {
  fromid_ = 0;
  clear_has_fromid();
}
inline ::google::protobuf::int32 MessageItem::fromid() const {
  return fromid_;
}
inline void MessageItem::set_fromid(::google::protobuf::int32 value) {
  set_has_fromid();
  fromid_ = value;
}

// optional int32 fromgid = 9;
inline bool MessageItem::has_fromgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageItem::set_has_fromgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageItem::clear_has_fromgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageItem::clear_fromgid() {
  fromgid_ = 0;
  clear_has_fromgid();
}
inline ::google::protobuf::int32 MessageItem::fromgid() const {
  return fromgid_;
}
inline void MessageItem::set_fromgid(::google::protobuf::int32 value) {
  set_has_fromgid();
  fromgid_ = value;
}

// optional bytes infoVersion = 10;
inline bool MessageItem::has_infoversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageItem::set_has_infoversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageItem::clear_has_infoversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageItem::clear_infoversion() {
  if (infoversion_ != &::google::protobuf::internal::kEmptyString) {
    infoversion_->clear();
  }
  clear_has_infoversion();
}
inline const ::std::string& MessageItem::infoversion() const {
  return *infoversion_;
}
inline void MessageItem::set_infoversion(const ::std::string& value) {
  set_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    infoversion_ = new ::std::string;
  }
  infoversion_->assign(value);
}
inline void MessageItem::set_infoversion(const char* value) {
  set_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    infoversion_ = new ::std::string;
  }
  infoversion_->assign(value);
}
inline void MessageItem::set_infoversion(const void* value, size_t size) {
  set_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    infoversion_ = new ::std::string;
  }
  infoversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageItem::mutable_infoversion() {
  set_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    infoversion_ = new ::std::string;
  }
  return infoversion_;
}
inline ::std::string* MessageItem::release_infoversion() {
  clear_has_infoversion();
  if (infoversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = infoversion_;
    infoversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 toId = 3;
inline bool MessageItem::has_toid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageItem::set_has_toid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageItem::clear_has_toid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageItem::clear_toid() {
  toid_ = 0;
  clear_has_toid();
}
inline ::google::protobuf::int32 MessageItem::toid() const {
  return toid_;
}
inline void MessageItem::set_toid(::google::protobuf::int32 value) {
  set_has_toid();
  toid_ = value;
}

// optional .lhchat.MessageKind msgKind = 4;
inline bool MessageItem::has_msgkind() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageItem::set_has_msgkind() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageItem::clear_has_msgkind() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageItem::clear_msgkind() {
  msgkind_ = 0;
  clear_has_msgkind();
}
inline lhchat::MessageKind MessageItem::msgkind() const {
  return static_cast< lhchat::MessageKind >(msgkind_);
}
inline void MessageItem::set_msgkind(lhchat::MessageKind value) {
  GOOGLE_DCHECK(lhchat::MessageKind_IsValid(value));
  set_has_msgkind();
  msgkind_ = value;
}

// required int32 showType = 5;
inline bool MessageItem::has_showtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageItem::set_has_showtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageItem::clear_has_showtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageItem::clear_showtype() {
  showtype_ = 0;
  clear_has_showtype();
}
inline ::google::protobuf::int32 MessageItem::showtype() const {
  return showtype_;
}
inline void MessageItem::set_showtype(::google::protobuf::int32 value) {
  set_has_showtype();
  showtype_ = value;
}

// required int32 contentType = 6;
inline bool MessageItem::has_contenttype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessageItem::set_has_contenttype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessageItem::clear_has_contenttype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessageItem::clear_contenttype() {
  contenttype_ = 0;
  clear_has_contenttype();
}
inline ::google::protobuf::int32 MessageItem::contenttype() const {
  return contenttype_;
}
inline void MessageItem::set_contenttype(::google::protobuf::int32 value) {
  set_has_contenttype();
  contenttype_ = value;
}

// required bytes contentData = 7;
inline bool MessageItem::has_contentdata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MessageItem::set_has_contentdata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MessageItem::clear_has_contentdata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MessageItem::clear_contentdata() {
  if (contentdata_ != &::google::protobuf::internal::kEmptyString) {
    contentdata_->clear();
  }
  clear_has_contentdata();
}
inline const ::std::string& MessageItem::contentdata() const {
  return *contentdata_;
}
inline void MessageItem::set_contentdata(const ::std::string& value) {
  set_has_contentdata();
  if (contentdata_ == &::google::protobuf::internal::kEmptyString) {
    contentdata_ = new ::std::string;
  }
  contentdata_->assign(value);
}
inline void MessageItem::set_contentdata(const char* value) {
  set_has_contentdata();
  if (contentdata_ == &::google::protobuf::internal::kEmptyString) {
    contentdata_ = new ::std::string;
  }
  contentdata_->assign(value);
}
inline void MessageItem::set_contentdata(const void* value, size_t size) {
  set_has_contentdata();
  if (contentdata_ == &::google::protobuf::internal::kEmptyString) {
    contentdata_ = new ::std::string;
  }
  contentdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageItem::mutable_contentdata() {
  set_has_contentdata();
  if (contentdata_ == &::google::protobuf::internal::kEmptyString) {
    contentdata_ = new ::std::string;
  }
  return contentdata_;
}
inline ::std::string* MessageItem::release_contentdata() {
  clear_has_contentdata();
  if (contentdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contentdata_;
    contentdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 generatedTime = 8;
inline bool MessageItem::has_generatedtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MessageItem::set_has_generatedtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MessageItem::clear_has_generatedtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MessageItem::clear_generatedtime() {
  generatedtime_ = GOOGLE_ULONGLONG(0);
  clear_has_generatedtime();
}
inline ::google::protobuf::uint64 MessageItem::generatedtime() const {
  return generatedtime_;
}
inline void MessageItem::set_generatedtime(::google::protobuf::uint64 value) {
  set_has_generatedtime();
  generatedtime_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace lhchat

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::UserInfoIndex>() {
  return lhchat::UserInfoIndex_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::ApplyMode>() {
  return lhchat::ApplyMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::ApplyType>() {
  return lhchat::ApplyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::SearchType>() {
  return lhchat::SearchType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::Applystate>() {
  return lhchat::Applystate_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::ApplyResult>() {
  return lhchat::ApplyResult_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::UserRelation>() {
  return lhchat::UserRelation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::MessageKind>() {
  return lhchat::MessageKind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::MsgQueueKind>() {
  return lhchat::MsgQueueKind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::ChannelKind>() {
  return lhchat::ChannelKind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< lhchat::OperateResultCode>() {
  return lhchat::OperateResultCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Struct_2eproto__INCLUDED
